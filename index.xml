<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sinowrt on Sinowrt</title>
    <link>http://blog.sinowrt.cn/</link>
    <description>Recent content in Sinowrt on Sinowrt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 01 Dec 2020 22:02:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>如何生成VMESS URL并发布订阅</title>
      <link>http://blog.sinowrt.cn/2020/2020-12-01t2202-how-to-generate-vmess-urls-and-public-as-subscription/</link>
      <pubDate>Tue, 01 Dec 2020 22:02:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-12-01t2202-how-to-generate-vmess-urls-and-public-as-subscription/</guid>
      <description>

&lt;h2 id=&#34;0x00-获得vmess-url&#34;&gt;0x00 获得VMESS URL&lt;/h2&gt;

&lt;p&gt;我使用的是V2rayN客户端，直接全选所有节点，然后&lt;code&gt;批量导出分享URL到剪切板&lt;/code&gt;即可&lt;/p&gt;

&lt;h2 id=&#34;0x01-发布订阅信息&#34;&gt;0x01 发布订阅信息&lt;/h2&gt;

&lt;p&gt;订阅信息实际上就是将VMESS URL（每个URL以回车符分隔）进行Base64加密，得到密文做成纯text网页，随便丢到一个安装了apache或nginx服务的服务器即可&lt;/p&gt;

&lt;p&gt;测试方法：在浏览器输入该订阅的网址，能访问到完整的Base64密文即可&lt;/p&gt;

&lt;h2 id=&#34;0x02-发布quantumult订阅信息&#34;&gt;0x02 发布quantumult订阅信息&lt;/h2&gt;

&lt;p&gt;quantumult的订阅信息格式跟V2rayN的不太一样，在这里我还踩了一个小坑，且听我详细道来&lt;/p&gt;

&lt;p&gt;这里要用到一个&lt;a href=&#34;https://quan.eicky.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;小工具&lt;/a&gt;，将V2rayN的vmess url转成符合Quantumult格式的vmess url&lt;/p&gt;

&lt;p&gt;这是示例的vmess url
&lt;code&gt;vmess://ew0KICAidiI6ICIyIiwNCiAgInBzIjogIuekuuS+iyIsDQogICJhZGQiOiAiMTkyLjE2OC4xLjEiLA0KICAicG9ydCI6ICI0MzIxIiwNCiAgImlkIjogImQ3NzFkODlhLTliZWQtNDc2Ny1hNjlkLTE5NjJkY2MyZTY3YyIsDQogICJhaWQiOiAiNjQiLA0KICAibmV0IjogIndzIiwNCiAgInR5cGUiOiAibm9uZSIsDQogICJob3N0IjogIiIsDQogICJwYXRoIjogIi9leGFtcGxlIiwNCiAgInRscyI6ICIiDQp9&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用小工具转换之后的Quantumult vmess url为&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vmess://56S65L6LID0gdm1lc3MsMTkyLjE2OC4xLjEsNDMyMSxub25lLCJkNzcxZDg5YS05YmVkLTQ3NjctYTY5ZC0xOTYyZGNjMmU2N2MiLG92ZXItdGxzPWZhbHNlLHRscy1ob3N0PSxjZXJ0aWZpY2F0ZT0xLG9iZnM9d3Msb2Jmcy1wYXRoPSIvZXhhbXBsZSJvYmZzLWhlYWRlcj0iSG9zdDoi&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先，比较一下V2rayN和Quantumult的vmess url,两者看似非常相似，除了&lt;code&gt;vmess://&lt;/code&gt;相同之外完全不一样。可是你说它不一样吧，它也没个规律比较啥也无从下手&lt;/p&gt;

&lt;p&gt;既然订阅密文是将vmess url 通过base64加密之后得到的，那么vmess://后面这一串东西是不是也是通过base64加密得到的密文呢，那就解密试试吧&lt;/p&gt;

&lt;p&gt;这是V2rayN的Vmess://后一串密文解密的结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;v&amp;quot;: &amp;quot;2&amp;quot;,
  &amp;quot;ps&amp;quot;: &amp;quot;示例&amp;quot;,
  &amp;quot;add&amp;quot;: &amp;quot;192.168.1.1&amp;quot;,
  &amp;quot;port&amp;quot;: &amp;quot;4321&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;d771d89a-9bed-4767-a69d-1962dcc2e67c&amp;quot;,
  &amp;quot;aid&amp;quot;: &amp;quot;64&amp;quot;,
  &amp;quot;net&amp;quot;: &amp;quot;ws&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;none&amp;quot;,
  &amp;quot;host&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;path&amp;quot;: &amp;quot;/example&amp;quot;,
  &amp;quot;tls&amp;quot;: &amp;quot;&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是Quantumult的Vmess://后一串密文解密的结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 = vmess,192.168.1.1,4321,none,&amp;quot;d771d89a-9bed-4767-a69d-1962dcc2e67c&amp;quot;,over-tls=false,tls-host=,certificate=1,obfs=ws,obfs-path=&amp;quot;/example&amp;quot;obfs-header=&amp;quot;Host:&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过比较，vmess://后面是base64加密的密文实锤了&lt;/p&gt;

&lt;p&gt;可是将这个vmess url追加到原有的url列表时，Quantumult却只能识别先前的url，而这个追加的无论是单独设为订阅，或是与原来的url一起设为订阅，都无法识别&lt;/p&gt;

&lt;p&gt;更神奇的是，小工具生成Quantumult订阅url时，会同时生成二维码，使用Quantumult应用扫描这个二维码，或者复制这个url通过剪贴板导入的方式，都可以成功识别并添加该服务器&lt;/p&gt;

&lt;p&gt;既然如此，那我们就看看这个Quantumult与原有的url列表中的服务器有什么不一样&lt;/p&gt;

&lt;p&gt;新的Quantumult vmess url&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 = vmess,192.168.1.1,4321,none,&amp;quot;d771d89a-9bed-4767-a69d-1962dcc2e67c&amp;quot;,over-tls=false,tls-host=,certificate=1,obfs=ws,obfs-path=&amp;quot;/example&amp;quot;obfs-header=&amp;quot;Host:&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;旧列表中的Quantumult vmess url&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 = vmess,192.168.1.1,4321,none,&amp;quot;d771d89a-9bed-4767-a69d-1962dcc2e67c&amp;quot;,group=Fndroid,over-tls=false,tls-host=,certificate=1,obfs=ws,obfs-path=&amp;quot;/example&amp;quot;obfs-header=&amp;quot;Host:&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，只是多了一个group字段，于是将原来的url添加上group字段，然后base64加密这段字符串追加到vmess://后面&lt;/p&gt;

&lt;p&gt;将这个vmess url追加到原有的vmess url列表中，并将列表进行base64加密，就可以发布订阅了&lt;/p&gt;

&lt;p&gt;当然这次是能够识别并添加成功了&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>安装新版v2ray服务端</title>
      <link>http://blog.sinowrt.cn/2020/2020-09-15t2314-how-to-install-the-lasted-v2ray/</link>
      <pubDate>Tue, 15 Sep 2020 23:14:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-09-15t2314-how-to-install-the-lasted-v2ray/</guid>
      <description>

&lt;h2 id=&#34;0x00-问题&#34;&gt;0x00 问题&lt;/h2&gt;

&lt;p&gt;在使用旧教程安装v2ray的时候，出现如下错误提示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR: This script has been DISCARDED, please switch to fhs-install-v2ray project.
HOW TO USE: https://github.com/v2fly/fhs-install-v2ray
TO MIGRATE: https://github.com/v2fly/fhs-install-v2ray/wiki/Migrate-from-the-old-script-to-this
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意思是旧版的安装脚本已经停止使用，可以到&lt;code&gt;https://github.com/v2fly/fhs-install-v2ray&lt;/code&gt;查看新脚本的使用说明&lt;/p&gt;

&lt;h2 id=&#34;0x01-安装步骤&#34;&gt;0x01 安装步骤&lt;/h2&gt;

&lt;h3 id=&#34;1-使用新脚本安装v2ray&#34;&gt;1.使用新脚本安装v2ray&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;bash &amp;lt;(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-配置config-json文件&#34;&gt;2.配置config.json文件&lt;/h3&gt;

&lt;p&gt;需要注意的是，新版的config.json文件默认路径从&lt;code&gt;\etc\v2ray\config.json&lt;/code&gt;换到了&lt;code&gt;\usr\local\etc\v2ray\config.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于我在本地备份又config.json，就不再重复配置了&lt;/p&gt;

&lt;p&gt;将自带的config.json重命名为config.json.bak，留个备份，然后用xftp把本地的config.json上传到服务器对应目录中&lt;/p&gt;

&lt;p&gt;要了解如何配置config.json的可以参考&lt;a href=&#34;https://blog.sinowrt.cn/2019/2019-06-13t1300-how-to-save-the-baned-ip/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;旧教程&lt;/a&gt;里面的服务端配置模板&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>群晖 moments 中的视频不显示缩略图</title>
      <link>http://blog.sinowrt.cn/2020/2020-08-16t2053-synology-moments-preview-pictures-of-videos-was-damaged/</link>
      <pubDate>Sun, 16 Aug 2020 14:27:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-08-16t2053-synology-moments-preview-pictures-of-videos-was-damaged/</guid>
      <description>

&lt;h2 id=&#34;0x00-问题描述&#34;&gt;0x00 问题描述&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;为了解决照片备份的问题，我在群晖上安装了moments，但是一直以来都有一个问题，就是备份的所有视频在moments里面的缩略图都是显示损坏的，看着很不是滋味，就上网查了一下是什么原因。一圈下来，都说要看到缩略图的话，需要半洗白，那就洗白吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0x01-半洗白-其实根本不能解决问题&#34;&gt;0x01 半洗白（其实根本不能解决问题）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;根据网上的资料，半洗白一共有两种方法：&lt;/li&gt;
&lt;li&gt;一是通过算号，算出该型号的sn码，然后修改引导配置中的sn，从而达到半洗白&lt;/li&gt;
&lt;li&gt;二是通过再docker中安装DDSM，进入虚拟的群晖系统，获取体验的sn号，然后跟方法一同样的，将该SN填入引导配置中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而新版的docker中已经将DDSM功能去掉了，所以使用方法二的话，需要卸载重装旧版的docker，再下载pat安装体验版的系统。整个过程过于繁琐，就不考虑方法二了。&lt;/p&gt;

&lt;p&gt;所以下面就详细描述方法一的操作过程：&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>新浪爱问一面凉经</title>
      <link>http://blog.sinowrt.cn/2020/2020-08-04t1230-sina-iask-interview/</link>
      <pubDate>Tue, 04 Aug 2020 12:30:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-08-04t1230-sina-iask-interview/</guid>
      <description>

&lt;h2 id=&#34;新浪爱问一面凉经&#34;&gt;新浪爱问一面凉经&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;早上九点多就到超多维大厦了，还好一楼有个星巴克，抓紧时间复习了垃圾回收算法，三次握手，NIO相关知识，把自我介绍排了一遍。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;10:21上楼，首先在前台填了面试信息表，等了十几分钟后，被一个看发量就知道是一个资深技术的小哥带进去会议室了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;照例自我介绍了一波，然后小哥开始问问题：现在有一个新闻推送系统，每天由专人不定时录入新闻，现在需要将这些消息推送给用户，设计一个推送模块，在用户每次刷新的时候，用户都能收到固定数量的新闻，当然新闻可能有些是最新的，有些是比较旧的，如何保证用户在每次刷新的时候都能收到一部分新闻并且保证这些新闻不重复？&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;答：先是把数据库里面的新闻存储结构描述了一下，将每次查询到的新闻id，用户id关联存到redis，用户查询的时候，现在redis查询该用户所查询过的新闻id，然后再到数据库里面将redis查询的结果作为查询条件，排除掉已查询过的新闻，再返回新闻列表。&lt;/p&gt;

&lt;p&gt;问：这样的话又一个问题，redis里面的数据要持久化，并且随着用户查询的次数增多，数据量也越来越大，这样要怎样处理呢。&lt;/p&gt;

&lt;p&gt;答：这样的话可以在数据库里面新建一个表，将每次的查询的新闻id以及用户id关联一下，然后每次再进行连表查询。&lt;/p&gt;

&lt;p&gt;问：这样还是没有从根本上解决问题，随着用户的请求越来越多，该表的数据量也越来越大，性能也越来越慢。&lt;/p&gt;

&lt;p&gt;答：可以引入消息队列，将用户归类，并且对每一类用户的请求，将这一批请求放到消息队列，用户可对这些消息进行重复消费。&lt;/p&gt;

&lt;p&gt;问：这样处理确实可以缓解性能压力，但是还是不是最优方案。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算了，我再问你一些问题吧，在redis高并发的情况下，缓存失效应该怎么处理呢？（不好意思没了解过）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你做的系统最大的并发量有多少（最多应该是光大的，并发量大概在一千左右）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;hashmap是线程安全的还是线程不安全的？为什么线程不安全？&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;答：线程不安全，因为hashmap不具备可见性，当一个线程在hashmap插入了一个数据之后，但这个更新只在cpu高速缓存中体现，而并未即使更新到内存中，所以这就导致另一个线程在访问hashmap的时候读不到该值，所以是线程不安全的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用过事务吗，事务有哪几种传播方式（7种，具体名称记不住了）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;给了两个程序段，问testA方法调用会不会导致事务回滚，testB调用会不会导致事务回滚？
```java
@Service
public class PersonService{
@trasactional()
public int save(String id){
    Person person=new Person();
    person.setId(id);
    dao.save(person);
    throw new Exception(&amp;ldquo;&amp;rdquo;);
}&lt;/p&gt;

&lt;p&gt;//这个不会导致事务回滚，因为没用加入到spring的AOP
public void testA(){
    this.save(&amp;ldquo;000&amp;rdquo;);
}
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;public class testB{
    @Autowire
    PersonService personService;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//这个会导致回滚
public void testB(){
    personService.save(&amp;quot;000&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我说如果trasactional的rollback为true的话，两个都会回滚，否则两个都不回滚。(面试官有解释，见注释，解释完之后，就完了。。。)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我还是tyts了 :(&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>python3.8 在安装 python-docx 时提示未安装libxml2</title>
      <link>http://blog.sinowrt.cn/2020/2020-07-22t1231-could-not-find-function-xmlcheckversion-in-library-libxml2.-while-installing-python-docx/</link>
      <pubDate>Wed, 22 Jul 2020 12:31:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-07-22t1231-could-not-find-function-xmlcheckversion-in-library-libxml2.-while-installing-python-docx/</guid>
      <description>&lt;p&gt;因为Anaconda3的python环境在pyinstaller打包的时候，会把整个数学运算库打包进来，使整个程序体积达到300M以上，在分析程序运行时加载的动态链接库时，发现这些库在运行过程中都没有使用，虽然可以手动删除这些库，但是每次打包好了都要手动删除未免过于繁琐，所以打算把python切换一下，由于电脑里面之前已经安装了python3.8，所以只需要吧Anaconda3的环境取消激活就可以了。&lt;/p&gt;

&lt;p&gt;但是项目中所用到的一些包，都要重新安装一遍了。其中就包括python-docx这个模块，在安装的过程中报了&lt;code&gt;Could not find function xmlCheckVersion in library libxml2. Is libxml2 installed?&lt;/code&gt;这个错误。百度了一下，是缺少lxml引起的，需要到&lt;code&gt;https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml&lt;/code&gt;下载你所安装python版本的对应whl包，由于我的python是windows下的64位版本，于是我就下载了&lt;code&gt;lxml‑4.5.2‑cp38‑cp38‑win_amd64.whl&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下载完成后，只需cd到该whl包的路径上，执行&lt;code&gt;pip install lxml‑4.5.2‑cp38‑cp38‑win_amd64.whl&lt;/code&gt;就可以了。但是在安装的过程中却又出了点状况，提示&lt;code&gt;lxml-4.5.2-cp38-cp38-win32.whl is not a supported wheel on this platform.&lt;/code&gt;，百度发现是包名有问题，在python控制台中输入&lt;code&gt;import pip._internal; print(pip._internal.pep425tags.get_supported())&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[(&#39;cp38&#39;, &#39;cp38m&#39;, &#39;win_amd64&#39;), (&#39;cp38&#39;, &#39;none&#39;, &#39;win_amd64&#39;), (&#39;py3&#39;, &#39;none&#39;, &#39;win_amd64&#39;), (&#39;cp38&#39;, &#39;none&#39;, &#39;any&#39;), (&#39;cp3&#39;, &#39;none&#39;, &#39;any&#39;), (&#39;py38&#39;, &#39;none&#39;, &#39;any&#39;), (&#39;py3&#39;, &#39;none&#39;, &#39;any&#39;), (&#39;py37&#39;, &#39;none&#39;,
 &#39;any&#39;), (&#39;py36&#39;, &#39;none&#39;, &#39;any&#39;), (&#39;py35&#39;, &#39;none&#39;, &#39;any&#39;), (&#39;py34&#39;, &#39;none&#39;, &#39;any&#39;), (&#39;py33&#39;, &#39;none&#39;, &#39;any&#39;), (&#39;py32&#39;, &#39;none&#39;, &#39;any&#39;), (&#39;py31&#39;, &#39;none&#39;, &#39;any&#39;), (&#39;py30&#39;, &#39;none&#39;, &#39;any&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照第一个参数可知，将文件名修改为&lt;code&gt;lxml‑4.5.2‑cp38‑cp38m‑win_amd64.whl&lt;/code&gt;即可&lt;/p&gt;

&lt;p&gt;修改后，在该包对应的路径中执行&lt;code&gt;pip install lxml‑4.5.2‑cp38‑cp38m‑win_amd64.whl&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(newvenv) E:\checkDuplicate&amp;gt;pip install lxml-4.5.2-cp38-cp38m-win_amd64.whl
Processing e:\checkduplicate\lxml-4.5.2-cp38-cp38m-win_amd64.whl
Installing collected packages: lxml
Successfully installed lxml-4.5.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一条命令｜康康谁动了我的vps</title>
      <link>http://blog.sinowrt.cn/2020/2020-06-28t1610-find-out-the-attacker-who-attacked-your-vps/</link>
      <pubDate>Sun, 28 Jun 2020 16:10:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-06-28t1610-find-out-the-attacker-who-attacked-your-vps/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;今天无意中发现了一个非常有用的命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;lastb ss -t&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>帮酒店修复网络</title>
      <link>http://blog.sinowrt.cn/2020/2020-06-12t1436-help-bojue-hotel-to-repair-the-wireless/</link>
      <pubDate>Fri, 12 Jun 2020 14:36:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-06-12t1436-help-bojue-hotel-to-repair-the-wireless/</guid>
      <description>

&lt;h3 id=&#34;0x00-事由&#34;&gt;0x00 事由&lt;/h3&gt;

&lt;p&gt;最近在外地出差，我住的酒店环境还不错，就是我这个房间的网络down了，提示宽带密码错误。
&lt;img src=&#34;http://pic.sinowrt.cn/image/2020-06-14T1436/wrong%20password.png&#34; alt=&#34;image&#34; /&gt;
于是我就连了楼上相同房间号的wifi。但是始终是隔着一层水泥板，信号不怎么好。于是我就想，那就进后台找一下宽带密码，修复一下我房间的wifi吧。&lt;/p&gt;

&lt;h3 id=&#34;0x01-步骤&#34;&gt;0x01 步骤&lt;/h3&gt;

&lt;p&gt;首先route -n get default查看默认网关，一般这种盒子的网关就是路由的管理后台地址，得到网关地址为192.168.125.1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sh-3.2# route -n get default 
   route to: default
destination: default
       mask: default
    gateway: 192.168.125.1
  interface: en0
      flags: &amp;lt;UP,GATEWAY,DONE,STATIC,PRCLONING&amp;gt;
 recvpipe  sendpipe  ssthresh  rtt,msec    rttvar  hopcount      mtu     expire
       0         0         0         0         0         0      1500         0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在浏览器输入地址192.168.125.1，打开后台登陆界面，还要输入用户名和密码&lt;/p&gt;

&lt;p&gt;根据经验输入最常见的用户名admin 密码admin，回车，进去了&lt;/p&gt;

&lt;p&gt;找到wan口设置，账户名直接能看到，密码用点号隐藏了，于是使出F12大法找到密码&lt;/p&gt;

&lt;p&gt;然后连到我房间这个路由器,进入后台把密码填进去就可以了，跟前面是一样的步骤，就不赘述了&lt;/p&gt;

&lt;p&gt;设置完保存&amp;amp;应用，等待设置生效后，ping一下看看网络通不通&lt;/p&gt;

&lt;p&gt;搞定！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Macbook Pro 2019使用感受</title>
      <link>http://blog.sinowrt.cn/2020/2020-06-10t1511-the-using-feeling-of-mbp/</link>
      <pubDate>Wed, 10 Jun 2020 14:27:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-06-10t1511-the-using-feeling-of-mbp/</guid>
      <description>&lt;p&gt;机器是今年年初买的，当时不想用公司的电脑，我就把神船带到公司当主力机。&lt;/p&gt;

&lt;p&gt;神船的性能是没得说的，但是这个重量(5kg)要背着上班通勤的话，我相信非习武之人绝对是承受不住的。&lt;/p&gt;

&lt;p&gt;于是我就打算将神船留在公司，可是回家就没电脑用了呀，而且身为IT人无论身在何处，随身携带电脑是我们光荣的使命。所以就萌发了购置macbook pro的想法。&lt;/p&gt;

&lt;p&gt;作为开发人员，16g内存是必选的，硬盘如果有条件还是建议512起步。但由于当时手头拮据，只选配了256的。新macbook pro在今年五月发布了，cpu 键盘 内存 硬盘 全线升级，如果上天再给我一次机会的话，我一定会等这四个月。&lt;/p&gt;

&lt;p&gt;使用macbook最直接的感受就是它超长的续航了，正常办公使用5h+没问题。而且随用随关，不用时只要把盖合上实属省心。&lt;/p&gt;

&lt;p&gt;现在我日常都是本地mac+远程win双端办公，只要有网络的地方都可以双端无缝切换，省心得很。&lt;/p&gt;

&lt;p&gt;macbook使用到现在也有小半年了，大问题没有，小问题比如说finder的远程服务器连接实属蹩脚，系统偶尔也会开小猜，不过重启都能解决问题。但是我这个人就是不喜欢重启电脑，只要不出问题，我宁愿它7x24不间断服务。&lt;/p&gt;

&lt;p&gt;前段时间还遇到了 macbook pro 2019 siri无法找到麦克风的问题，重启电脑即可解决。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Macbook Pro查看电池信息</title>
      <link>http://blog.sinowrt.cn/2020/2020-06-10t1427-how-to-query-the-information-of-battery-on-mac/</link>
      <pubDate>Wed, 10 Jun 2020 14:27:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-06-10t1427-how-to-query-the-information-of-battery-on-mac/</guid>
      <description>&lt;p&gt;在终端输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ioreg -rn AppleSmartBattery | grep -i capacity
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;AppleRawCurrentCapacity&amp;quot; = 4867
&amp;quot;AppleRawMaxCapacity&amp;quot; = 5084
&amp;quot;MaxCapacity&amp;quot; = 5084
&amp;quot;CurrentCapacity&amp;quot; = 4867
&amp;quot;LegacyBatteryInfo&amp;quot; = {&amp;quot;Amperage&amp;quot;=18446744073709551214,&amp;quot;Flags&amp;quot;=4,&amp;quot;Capacity&amp;quot;=5084,&amp;quot;Current&amp;quot;=4867,&amp;quot;Voltage&amp;quot;=12729,&amp;quot;Cycle Count&amp;quot;=46}
&amp;quot;DesignCapacity&amp;quot; = 5088
&amp;quot;BatteryData&amp;quot; = {&amp;quot;StateOfCharge&amp;quot;=96,&amp;quot;PMUConfigured&amp;quot;=0,&amp;quot;Voltage&amp;quot;=12699,&amp;quot;QmaxCell1&amp;quot;=5358,&amp;quot;AdapterPower&amp;quot;=839469241,&amp;quot;SystemPower&amp;quot;=1087516262,&amp;quot;ResScale&amp;quot;=117,&amp;quot;QmaxCell2&amp;quot;=5302,&amp;quot;QmaxCell0&amp;quot;=5341,&amp;quot;CycleCount&amp;quot;=46,&amp;quot;DesignCapacity&amp;quot;=5088}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关闭chrome浏览器广告弹窗</title>
      <link>http://blog.sinowrt.cn/2020/2020-05-27t1334-remove-the-ad-windows-of-chrome/</link>
      <pubDate>Wed, 27 May 2020 13:34:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-05-27t1334-remove-the-ad-windows-of-chrome/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;之前用google进行调研的时候，点进去了一个网站
![]()
迫于打开心切，就点击了允许，之后时不时就会出现Bestdealfor10.life的弹窗，想要禁用，百度无果，使用google发现很多解决方法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;随便挑一个&lt;a href=&#34;https://malwaretips.com/blogs/remove-bestdealfor10-life/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://malwaretips.com/blogs/remove-bestdealfor10-life/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;按步骤，在chrome的设置-隐私和安全-网站设置-通知里面将&lt;a href=&#34;https://bestdealfor10.life&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://bestdealfor10.life&lt;/a&gt; 移除即可&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>优美的switch</title>
      <link>http://blog.sinowrt.cn/2020/2020-05-20t1507-javagorgeous-switch/</link>
      <pubDate>Wed, 20 May 2020 15:07:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-05-20t1507-javagorgeous-switch/</guid>
      <description>&lt;p&gt;相信大家都有这种体会，工作以来一直都是自己写代码，感觉自己的代码总是平平无奇，运行倒是能运行，就是没有那种让人眼前一亮的感觉。而每次阅读别人的源码，心里一直再默念，卧槽，还能这样写，天哪，太精辟了！&lt;/p&gt;

&lt;p&gt;于是，我就想，把这些让人眼前一亮的代码都摘录下来。一方面，自己能学习留痕，二来也能把这些知识分享给大家。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static String createPlayer(PlayerTypes playerType) {
    return switch (playerType) {
        case TENNIS -&amp;gt; &amp;quot;网球运动员费德勒&amp;quot;;
        case FOOTBALL -&amp;gt; &amp;quot;足球运动员C罗&amp;quot;;
        case BASKETBALL,PINGPANG -&amp;gt; &amp;quot;牛逼运动员&amp;quot;;
        case UNKNOWN -&amp;gt; throw new IllegalArgumentException(&amp;quot;未知&amp;quot;);
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，代码的优化应该在保证业务正常运行的前提下进行，下面我讲一个有隐患的代码优化例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map map=new HashMap(){{
    put(&amp;quot;key&amp;quot;,&amp;quot;value&amp;quot;);
}};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种写法，比起新建HashMap对象后再一个个put值，虽然是提高了代码的整体性，但是却存在着致命的缺陷，这也是我在搭地铁刷掘金时在一篇文章上看到的&lt;/p&gt;

&lt;p&gt;首先给出结论：这种写法会导致抛出OOM异常&lt;/p&gt;

&lt;p&gt;因为在new HashMap时，是调用了一个匿名内部类的put方法，而根据引用计数法，这个对象一直持有外部类的引用，导致该对象在GC时无法清除，埋下了OOM的隐患。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mac 安装flutter</title>
      <link>http://blog.sinowrt.cn/2020/2020-05-12t1531-how-to-install-flutter-on-mac/</link>
      <pubDate>Tue, 12 May 2020 15:31:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-05-12t1531-how-to-install-flutter-on-mac/</guid>
      <description>&lt;p&gt;首先从官网将flutter稳定版的压缩包下载下来，然后解压到一个目录中，
vi ~/.zshrc
添加以下一行
export PATH=/(解压flutter的路径)/flutter/bin:$PATH
保存然后source ~/.zshrc&lt;/p&gt;

&lt;p&gt;接下来flutter -h，却提示
&lt;code&gt;无法打开“Dart”，因为apple无法检查其是否包含恶意软件&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;输入以下命令回车（会提示输入密码）即可解决：
sudo spctl &amp;ndash;master-disable&lt;/p&gt;

&lt;p&gt;再次输入flutter -h验证是否生效&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>记一次生产环境 日期查询错误</title>
      <link>http://blog.sinowrt.cn/2020/2020-04-21t1011-date-query-error-in-product-environment/</link>
      <pubDate>Tue, 21 Apr 2020 10:11:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-04-21t1011-date-query-error-in-product-environment/</guid>
      <description>&lt;p&gt;如图&lt;/p&gt;

&lt;p&gt;想查询4月1日到21日的记录，可是却连着3月31日的记录都查到了&lt;/p&gt;

&lt;p&gt;到后端查看日志，显示查询开始日期为31日16时，那么基本断定是时区出了问题&lt;/p&gt;

&lt;p&gt;那么有几种可能，一是系统时区，一是数据库时区，三是docker容器内部的时区&lt;/p&gt;

&lt;p&gt;第一步，&lt;code&gt;date -R&lt;/code&gt;查看系统时区输出&lt;code&gt;Tue, 21 Apr 2020 09:31:18 +0800&lt;/code&gt;,东八区，没问题&lt;/p&gt;

&lt;p&gt;那么第二步，查看数据库时区，登录mysql，&lt;code&gt;show variables like &amp;quot;%time_zone%&amp;quot;;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &amp;quot;%time_zone%&amp;quot;;
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| system_time_zone | UTC    |
| time_zone        | SYSTEM |
+------------------+--------+
2 rows in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟随系统，也没问题，需要注意的是，如果mysql是部署在docker中的话，就要进入容器内部更改容器内部的时区了&lt;/p&gt;

&lt;p&gt;保守起见，可以指定mysql的时区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set global time_zone = &#39;+8:00&#39;;
set time_zone = &#39;+8:00&#39;;
set time_zone = &#39;+8:00&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次查看mysql时区，已经改变了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &amp;quot;%time_zone%&amp;quot;;
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| system_time_zone | UTC    |
| time_zone        | +08:00 |
+------------------+--------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一开始看了前面两个的时区后，发现都没问题，纳闷了好久，后来才想起服务是部署在docker的啊，于是输入&lt;code&gt;docker exec -it 容器ID bash&lt;/code&gt;进入容器&lt;/p&gt;

&lt;p&gt;输入&lt;code&gt;date -R&lt;/code&gt;,显示&lt;code&gt;Tue, 21 Apr 2020 01:40:28 +0000&lt;/code&gt;,终于找到原因了&lt;/p&gt;

&lt;p&gt;于是输入&lt;code&gt;cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/code&gt;,却提示
&lt;code&gt;cp: can&#39;t stat &#39;/usr/share/zoneinfo/Asia/Shanghai&#39;: No such file or directory&lt;/code&gt;，容器内部是没有这些时区文件的，那么就要从宿主机上面拷贝一份进来&lt;/p&gt;

&lt;p&gt;首先&lt;code&gt;mkdir -p /usr/share/zoneinfo/Asia&lt;/code&gt;创建文件夹&lt;/p&gt;

&lt;p&gt;再&lt;code&gt;ctrl+D&lt;/code&gt;退出容器，执行&lt;code&gt;docker cp /usr/share/zoneinfo/Asia/Shanghai d2e85b301fae:/usr/share/zoneinfo/Asia&lt;/code&gt;
再次进入容器，执行&lt;code&gt;cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/code&gt;即可&lt;/p&gt;

&lt;p&gt;可以通过&lt;code&gt;date -R&lt;/code&gt;进行验证，显示&lt;code&gt;Tue, 21 Apr 2020 01:42:18 +0800&lt;/code&gt;,大功告成&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker save 和 export 命令的区别</title>
      <link>http://blog.sinowrt.cn/2020/2020-04-20t1611-the-differences-of-docker-command-save-and-export/</link>
      <pubDate>Mon, 20 Apr 2020 16:11:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-04-20t1611-the-differences-of-docker-command-save-and-export/</guid>
      <description>

&lt;p&gt;在一次生产环境 docker 微服务更新 中 深刻意识到docker save 和 export 的区别&lt;/p&gt;

&lt;h3 id=&#34;0x00-背景&#34;&gt;0x00 背景&lt;/h3&gt;

&lt;p&gt;上次使用虚拟机镜像部署了三个子系统，但是测试过程中还是发现了不少问题，所以这次需要过去更新几个微服务&lt;/p&gt;

&lt;p&gt;于是就在公司虚拟机里面用export命令把几个容器导出来，放到生产环境中再import进去，然后run，结果死活运行不起来，提示run缺少参数。为了防止这种情况，我还把公司测试环境中的完整的容器启动命令都拍了下来，然后尝试构造命令，没有参数是吧，我用inspect命令把参数都找出来。接下来参数是不缺了，就是提示在工作目录中找不到文件。&lt;/p&gt;

&lt;h3 id=&#34;0x01-分析&#34;&gt;0x01 分析：&lt;/h3&gt;

&lt;p&gt;在公司里面的容器，我是直接通过2375端口直接上传到docker镜像库的，在上传完毕后，还会执行dockerfile里面的命令，其中包含创建工作目录等命令。但是我将容器导入生产环境后，似乎是因为没有运行这些命令而造成找不到文件。&lt;/p&gt;

&lt;p&gt;那么就可以推理出，我只是将docker的容器导出来了，但是容器里面的数据却没有导出。&lt;/p&gt;

&lt;p&gt;怎样才能连同数据一起导出呢，那么就要用到save命令而不是export命令了。&lt;/p&gt;

&lt;h3 id=&#34;0x02-解决&#34;&gt;0x02 解决：&lt;/h3&gt;

&lt;p&gt;最后只能让同事再帮忙将这几个微服务的容器重新导出一下&lt;/p&gt;

&lt;p&gt;然后我这边再使用load命令将容器加载为镜像，微服务才得以成功更新。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>宿主机转发未开启导致无法访问docker内部网络</title>
      <link>http://blog.sinowrt.cn/2020/2020-04-17t1702-can-not-access-the-nacos-service-in-docker-container/</link>
      <pubDate>Fri, 17 Apr 2020 17:02:00 +0800</pubDate>
      
      <guid>http://blog.sinowrt.cn/2020/2020-04-17t1702-can-not-access-the-nacos-service-in-docker-container/</guid>
      <description>&lt;p&gt;今天迁移了虚拟机之后，准备上nacos改一下配置，可是登录http://&lt;strong&gt;&lt;em&gt;.&lt;/em&gt;&lt;/strong&gt;.&lt;strong&gt;&lt;em&gt;.&lt;/em&gt;&lt;/strong&gt;:8848/nacos却连接超时，telnet一下也不通，于是上部署了nacos的docker容器的宿主机上，curl &lt;a href=&#34;http://docker内网ip:8848/nacos&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://docker内网ip:8848/nacos&lt;/a&gt; 却是有返回数据的，那就确定应该是转发出了问题，&lt;/p&gt;

&lt;p&gt;sysctl -a | grep net.ipv4.ip_forward&lt;/p&gt;

&lt;p&gt;显示&lt;/p&gt;

&lt;p&gt;net.ipv4.ip_forward = 0&lt;/p&gt;

&lt;p&gt;原来是转发没开启，于是&lt;/p&gt;

&lt;p&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward&lt;/p&gt;

&lt;p&gt;sysctl -p 重新加载内核参数&lt;/p&gt;

&lt;p&gt;再telnet一下，通了搞定&lt;/p&gt;

&lt;p&gt;上http://&lt;strong&gt;&lt;em&gt;.&lt;/em&gt;&lt;/strong&gt;.&lt;strong&gt;&lt;em&gt;.&lt;/em&gt;&lt;/strong&gt;:8848/nacos进行配置就行了&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>